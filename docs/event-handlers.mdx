---
id: event-handlers
title: Writing Event Handlers
sidebar_label: Writing Event Handlers
slug: /event-handlers
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# Writing Event Handlers

Once the configuration and schema files are in place, run

```bash
envio codegen
```

in the project directory to generate the functions you will use in your handlers.

Each event requires two functions to be registered:

1. `loader` function
1. `handler` function

## Loader function

Loader functions are called via

<Tabs>
  <TabItem value="javascript" label="Javascript">

```javascript
<ContractName>Contract.<EventName>.loader
```

  </TabItem>
  <TabItem value="typescript" label="Typescript">

```typescript
<ContractName>Contract_ < EventName > _loader;
```

  </TabItem>
  <TabItem value="rescript" label="Rescript">

```rescript
<ContractName>Contract.<EventName>.loader
```

  </TabItem>
</Tabs>

Loader functions are used to load the specific entities (defined in the `schema.graphql`) that should be modified by the event.

Entities with specific IDs can be loaded via `context.<EntityName>.<label>Load(<id>)`.

If no [labels](./labels) has been defined in the `config.yaml` file, then entities can be loaded via `context.<EntityName>.load(<id>)`. You can call this `.load` function to load as many entities as you want to be available in your handler.

> Dev note: ðŸ“¢ For indexers built using `ReScript`, use a lower case for first letter of entityName when accessing it via context (i.e. `context.user` instead of `context.User`).

A single event can be used to load single or multiple entities in the loader (and modify/create as many entities as you want in the handler).

**Note**: that if no `required_entities` are set for the event, then all entities can be used in the loader for that event. However if it is set, only entities in the `required_entities` can be loaded for that event.

### `labels` and `arrayLabels`

To make your code more robust and explicit you can use the advanced features [here](./labels).

## Handler function

Handler functions are called via

<Tabs>
  <TabItem value="javascript" label="Javascript">

```jacvascript
<ContractName>Contract.<EventName>.handler
```

  </TabItem>
  <TabItem value="typescript" label="Typescript">

```typescript
<ContractName>Contract_ < EventName > _handler;
```

  </TabItem>
  <TabItem value="rescript" label="Rescript">

```rescript
<ContractName>Contract.<EventName>.handler
```

  </TabItem>
</Tabs>

Handler functions are used to modify the entities which have been loaded by the loader function, and thus should contain all the required logic for updating entities with the raw data emitted by the event.

All of the parameters emitted in each event are accessible via `event.params.<parameterName>`.

Additional raw event information can also be accessed via `event.<rawInfo>`.

Below is a list of raw event information that can be accessed:

- `blockHash`
- `blockNumber`
- `blockTimestamp`
- `chainId`
- `eventId`
- `eventType`
- `logIndex`
- `srcAddress`
- `transactionHash`
- `transactionIndex`

Handler functions can access the loaded entities that were loaded in the handler via `context.<EntityName>.<label>Load`, they can access these loaded entities via `context.<EntityName>.get(<id>)`.

> Dev note: ðŸ“¢ For indexers built using `ReScript`, use a lower case for first letter of entityName when accessing it via context (i.e. `context.user` instead of `context.User`).

Handler functions can also provides the following functions per loaded entity, that can be used to interact with that entity:

- set
- delete

which can be used as follows `context.<entityName>.set(<entityObject>)` and `context.<EntityName>.delete()`.

### Greeter example

Inspecting the `config.yaml` of the `NewGreeting` event, it indicates that there is a defined `requiredEntities` field of the following:

```yaml
events:
  - name: "NewGreeting"
```

### Example of a Loader function for the `NewGreeting` event:

<Tabs>
  <TabItem value="javascript" label="Javascript">

```javascript
let { GreeterContract } = require("../generated/src/Handlers.bs.js");

GreeterContract.NewGreeting.loader((event, context) => {
  context.User.load(event.params.user.toString());
});
```

  </TabItem>
  <TabItem value="typescript" label="Typescript">

```typescript
import { GreeterContract_NewGreeting_loader } from "../generated/src/Handlers.gen";

import { userEntity } from "../generated/src/Types.gen";

GreeterContract_NewGreeting_loader(({ event, context }) => {
  context.User.load(event.params.user.toString());
});
```

  </TabItem>
  <TabItem value="rescript" label="Rescript">

```rescript
open Types

Handlers.GreeterContract.NewGreeting.loader((~event, ~context) => {
  context.user.load(event.params.user->Ethers.ethAddressToString)
})
```

  </TabItem>
</Tabs>

- Within the function that is being registered, the user must define the criteria for loading the greeting entity.
- This is made available to the user through the load entity context defined as `contextUpdator`.
- In the case of the above example, we load a `User` entity that corresponds to the id passed from the event.

### Example of registering a Handler function for the `NewGreeting` event:

<Tabs>
  <TabItem value="javascript" label="Javascript">

```javascript
let { GreeterContract } = require("../generated/src/Handlers.bs.js");

GreeterContract.NewGreeting.handler((event, context) => {
  let existingUser = context.User.get(event.params.user.toString());

  if (existingUser != undefined) {
    context.User.set({
      id: event.params.user.toString(),
      latestGreeting: event.params.greeting,
      numberOfGreetings: existingUser.numberOfGreetings + 1,
      greetings: [...existingUser.numberOfGreetings, event.params.greeting],
    });
  } else {
    context.User.set({
      id: event.params.user.toString(),
      latestGreeting: event.params.greeting,
      numberOfGreetings: 1,
      greetings: [event.params.greeting],
    });
  }
});
```

  </TabItem>
  <TabItem value="typescript" label="Typescript">

```typescript
import { GreeterContract_NewGreeting_handler } from "../generated/src/Handlers.gen";

import { userEntity } from "../generated/src/Types.gen";

GreeterContract_NewGreeting_handler(({ event, context }) => {
(({ event, context }) => {
  let currentUser = context.User.get(event.params.user.toString());

  if (currentUser != null) {
    let userObject: userEntity = {
      id: event.params.user.toString(),
      latestGreeting: event.params.greeting,
      numberOfGreetings: currentUser.numberOfGreetings + 1,
      greetings: [...existingUser.numberOfGreetings, event.params.greeting],
    };

    context.User.set(userObject);
  } else {
    let userObject: userEntity = {
      id: event.params.user.toString(),
      latestGreeting: event.params.greeting,
      numberOfGreetings: 1,
      greetings: [event.params.greeting],
    };
    context.User.set(userObject);
  }
});
```

  </TabItem>
  <TabItem value="rescript" label="Rescript">

```rescript
open Types

Handlers.GreeterContract.NewGreeting.handler((~event, ~context) => {
  let currentUserOpt = context.user.get(event.params.user->Ethers.ethAddressToString)

  switch currentUserOpt {
  | Some(existingUser) => {
      let userObject: userEntity = {
        id: event.params.user->Ethers.ethAddressToString,
        latestGreeting: event.params.greeting,
        numberOfGreetings: existingUser.numberOfGreetings + 1,
        greetings: existingUser.greetings->Belt.Array.concat([event.params.greeting]),
      }

      context.user.set(userObject)
    }

  | None =>
    let userObject: userEntity = {
      id: event.params.user->Ethers.ethAddressToString,
      latestGreeting: event.params.greeting,
      numberOfGreetings: 1,
      greetings: [event.params.greeting],
    }

    context.user.set(userObject)
  }
})
```

  </TabItem>
</Tabs>

- Once the user has defined their `loader` function, they are then able to retrieve the loaded entity information.
- In the above example, if a `User` entity is found matching the load criteria in the `loader` function, it will be available via `greetingWithChanges`.
- This is made available to the user through the handler context defined simply as `context`.
- This `context` is the gateway by which the user can interact with the indexer and the underlying database.
- The user can then modify this retrieved entity and subsequently update the `User` entity in the database.
- This is done via the `context` using the function (`context.User.set(userObject)`).
- The user has access to a `userEntity` type that has all the fields defined in the schema.

---
