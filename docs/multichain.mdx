---
id: multichain-indexing
title: Multichain Indexing
sidebar_label: Multichain Indexing
slug: /multichain-indexing
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

This page explains how to index from multiple chains in a single indexer.

This means that events from contracts deployed on multiple chains can be used to create and update entities defined in the schema file.

Users are required to populate the `network` section in `config.yaml` file for each chain and specify a contract to index from.

Users can then specify event loader/handler for each of the contracts specified in `config.yaml` file.

## Multichain Indexing on Greeter template

### Config file

```yaml
name: Greeter
description: Greeter indexer
#Global contract definitions that must contain all definitions except
#addresses. Now you can share a single handler/abi/event definitions
#for contracts across multiple chains
contracts:
  - name: Greeter
    abi_file_path: ./abis/greeter-abi.json
    handler: ./src/EventHandlers.js
    events:
      - event: "NewGreeting"
        requiredEntities:
          - name: "Greeting"
      - event: "ClearGreeting"
        requiredEntities:
          - name: "Greeting"
networks:
  - id: 137 # Polygon
    start_block: 45336336
    contracts:
      - name: Greeter #A reference to the global contract definition
        address: "0x9D02A17dE4E68545d3a58D3a20BbBE0399E05c9c"
  - id: 59144 # Linea
    start_block: 367801
    contracts:
      - name: Greeter #A reference to the global contract definition
        address: "0xdEe21B97AB77a16B4b236F952e586cf8408CF32A"
```

The Greeter indexer listens to `NewGreeting` and `ClearGreeting` events from `Greeter` contract (which is defined above networks as a "global contract") to update the `Greeting` entity.

Notice how the global definition of the "Greeter" contract does not contain any addresses. And in the contracts section of both Polygon and Linea networks, they simply reference the name of the contract ("Greeter") and define the address. Both of these will use the same handler functions and events.

### Schema file

```graphql
type Greeting {
  id: ID!
  greetings: [String!]!
  latestGreeting: String!
  numberOfGreetings: Int!
}
```

### Event Handler file

<Tabs>
  <TabItem value="javascript" label="Javascript">

```javascript
let { GreeterContract } = require("../generated/src/Handlers.bs.js");

GreeterContract.NewGreeting.loader((event, context) => {
  context.Greeting.load(event.params.user);
});

GreeterContract.NewGreeting.handler((event, context) => {
  let user = event.params.user;
  let latestGreeting = event.params.greeting;
  let numberOfGreetings = event.params.numberOfGreetings;

  let existingGreeter = context.Greeting.get(event.params.user);

  if (existingGreeter !== undefined) {
    context.Greeting.set({
      id: user,
      latestGreeting: latestGreeting,
      numberOfGreetings: existingGreeter.numberOfGreetings + 1,
      greetings: [...existingGreeter.greetings, latestGreeting],
    });
  } else {
    context.Greeting.set({
      id: user,
      latestGreeting: latestGreeting,
      numberOfGreetings: 1,
      greetings: [latestGreeting],
    });
  }
});

GreeterContract.ClearGreeting.loader((event, context) => {
  context.Greeting.load(event.params.user);
});

GreeterContract.ClearGreeting.handler((event, context) => {
  let existingGreeter = context.Greeting.get(event.params.user);
  if (existingGreeter !== undefined) {
    context.Greeting.set({
      id: user,
      latestGreeting: "",
      numberOfGreetings: existingGreeter.numberOfGreetings + 1,
      greetings: existingGreeter.greetings,
    });
  }
});
```

  </TabItem>
  <TabItem value="typescript" label="Typescript">

```typescript
import {
  GreeterContract_NewGreeting_loader,
  GreeterContract_NewGreeting_handler,
  GreeterContract_ClearGreeting_loader,
  GreeterContract_ClearGreeting_handler,
} from "../generated/src/Handlers.gen";

import { GreetingEntity } from "../generated/src/Types.gen";

GreeterContract_NewGreeting_loader(({ event, context }) => {
  context.Greeting.load(event.params.user.toString());
});

GreeterContract_NewGreeting_handler(({ event, context }) => {
  let currentGreeter = context.Greeting.get(event.params.user);

  if (currentGreeter != null) {
    let greetingObject: GreetingEntity = {
      id: event.params.user.toString(),
      latestGreeting: event.params.greeting,
      numberOfGreetings: currentGreeter.numberOfGreetings + 1,
      greetings: [...currentGreeter.greetings, event.params.greeting],
    };

    context.Greeting.set(greetingObject);
  } else {
    let greetingObject: GreetingEntity = {
      id: event.params.user.toString(),
      latestGreeting: event.params.greeting,
      numberOfGreetings: 1,
      greetings: [event.params.greeting],
    };
    context.Greeting.set(greetingObject);
  }
});

GreeterContract_ClearGreeting_loader(({ event, context }) => {
  context.Greeting.load(event.params.user.toString());
});

GreeterContract_ClearGreeting_handler(({ event, context }) => {
  let currentGreeter = context.Greeting.get(event.params.user);

  if (currentGreeter != null) {
    let greetingObject: GreetingEntity = {
      id: event.params.user.toString(),
      latestGreeting: "",
      numberOfGreetings: currentGreeter.numberOfGreetings,
      greetings: currentGreeter.greetings,
    };

    context.Greeting.set(greetingObject);
  }
});
```

  </TabItem>
  <TabItem value="rescript" label="Rescript">

```rescript
open Types

Handlers.GreeterContract.NewGreeting.loader((~event, ~context) => {
  context.greeting.load(event.params.user->Ethers.ethAddressToString)
})

Handlers.GreeterContract.NewGreeting.handler((~event, ~context) => {
  let currentGreeterOpt = context.greeting.get(event.params.user->Ethers.ethAddressToString)

  switch currentGreeterOpt {
  | Some(existingGreeter) => {
      let greetingObject: greetingEntity = {
        id: event.params.user->Ethers.ethAddressToString,
        latestGreeting: event.params.greeting,
        numberOfGreetings: existingGreeter.numberOfGreetings + 1,
        greetings: existingGreeter.greetings->Belt.Array.concat([event.params.greeting]),
      }

      context.greeting.set(greetingObject)
    }

  | None =>
    let greetingObject: greetingEntity = {
      id: event.params.user->Ethers.ethAddressToString,
      latestGreeting: event.params.greeting,
      numberOfGreetings: 1,
      greetings: [event.params.greeting],
    }

    context.greeting.set(greetingObject)
  }
})

Handlers.GreeterContract.ClearGreeting.loader((~event, ~context) => {
  context.greeting.load(event.params.user->Ethers.ethAddressToString)
  ()
})

Handlers.GreeterContract.ClearGreeting.handler((~event, ~context) => {
  let currentGreeterOpt = context.greeting.get(event.params.user->Ethers.ethAddressToString)

  switch currentGreeterOpt {
  | Some(existingGreeter) => {
      let greetingObject: greetingEntity = {
        id: event.params.user->Ethers.ethAddressToString,
        latestGreeting: "",
        numberOfGreetings: existingGreeter.numberOfGreetings,
        greetings: existingGreeter.greetings,
      }

      context.greeting.set(greetingObject)
    }

  | None => ()
  }
})
```

  </TabItem>
</Tabs>

---
